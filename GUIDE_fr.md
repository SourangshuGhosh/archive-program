
# Guide du coffre-fort de code GitHub
## Introduction
Cette archive, le GitHub Code Vault, a été créée par le programme d'archivage GitHub, dont la mission est de préserver les logiciels open source pour les générations futures. Vous lirez peut-être celui-ci dans un an ou dans mille, mais de toute façon, nous espérons que son contenu, et peut-être le concept même de l'open source, vous seront utiles.

Il s'agit principalement d'une archive de logiciels. Le logiciel est une série de commandes utilisées pour contrôler les actions d'un ordinateur. Un ordinateur est un appareil qui peut exécuter automatiquement des fonctions mathématiques tellement plus rapidement qu'un esprit humain qu'il a des pouvoirs bien au-delà de nous. Nos ordinateurs sont utilisés pour aider à explorer les secrets de l'univers, pour connecter toute l'humanité dans un réseau d'information omniprésent, pour manipuler des signaux assez rapidement pour transmettre des sons et projeter des images en mouvement détaillées sur des écrans électriques, et pour contrôler des machines extrêmement puissantes qui dépasse à la fois la capacité et la précision du travail humain.

Un ordinateur sans logiciel ne peut faire aucune de ces choses. Un ordinateur est une chose extraordinaire et merveilleuse, mais sans logiciel, toute sa puissance est inutile. Le but de ces archives est de vous transmettre ce que nous savons sur les logiciels.

Les logiciels sont écrits sous la forme de séquences de commandes complexes mais lisibles par l'homme, dont les différentes saveurs sont appelées langages de programmation, car une unité complète de logiciels est souvent appelée programme. Ces programmes sont ensuite convertis dans le langage binaire des uns et des zéros utilisé par les ordinateurs. Ce processus est connu sous le nom de compilation.

Étant donné que le logiciel compilé est très difficile à déchiffrer dans sa forme de programme d'origine, également connue sous le nom de code source, il est possible pour les gens de garder cette forme originale secrète et d'en revendiquer la propriété. Les logiciels open source ne sont pas un type de logiciel différent, mais une philosophie différente. L'éthique open source rejette le secret et la propriété. Les logiciels open source sont mis à la disposition de tous ceux qui souhaitent les utiliser, sans frais, afin qu'ils puissent à leur tour améliorer ces programmes ou les utiliser pour créer quelque chose de nouveau et de meilleur.

Un projet open source est le travail collectif d'une communauté auto-organisée qui peut se compter par milliers. L'accumulation de tous les projets de logiciels open source archivés ici est l'œuvre d'une communauté de plusieurs millions de personnes. Bien que certaines personnes puissent avoir des droits spéciaux dans un projet donné, comme la possibilité d'approuver ou de rejeter les modifications suggérées à la dernière version officielle de son code source, personne ne la possède jamais. Chaque personne a le droit de prendre et d'utiliser une copie complète de tout projet open source à tout moment, sans frais ni pénalité. C'est ce qu'on appelle la création d'un projet.

Lorsque de nombreuses personnes travaillent sur le code source en même temps, il est difficile de suivre et d'intégrer toutes leurs modifications. Un projet open source appelé «Git» est consacré à la résolution de ce problème. Il intègre un historique complet de tous les ajouts et modifications d'un projet dans une entité connue sous le nom de référentiel Git. Cette archive est essentiellement une archive de ces référentiels.

Cette archive a été créée par une société nommée `` GitHub '', qui fournit un service qui permet aux utilisateurs du monde entier de stocker les logiciels qu'ils ont écrits, de suivre les modifications apportées à ces programmes et de collaborer avec d'autres pour les améliorer et les développer. GitHub met ses services gratuitement à la disposition des développeurs de logiciels publics open source. Il compte des dizaines de millions d'utilisateurs

Ce qui suit est une description de ce que nous pensons avoir besoin de savoir et d'avoir afin de tirer le meilleur parti de cette archive logicielle. Si vous ne savez pas ou ne comprenez pas tout ou partie de cela, ne désespérez pas! Nous avons également inclus un guide sur la manière de répondre à ces exigences. Si pour une raison quelconque vous ne pouvez pas les accomplir vous-mêmes, alors vos descendants le peuvent.

## Ce dont vous avez besoin pour utiliser l'archive

En principe, tout ce dont vous avez besoin pour accéder au contenu de cette archive est une source d'éclairage et une sorte de loupe. Cependant, la plupart (mais pas toutes) de ses données ont été emballées très étroitement sur des bobines de film sous une forme codée et compressée. La lecture, le décodage et la décompression de ces données exigeront en soi un calcul considérable. En théorie, cela pourrait se faire sans ordinateur, mais ce serait très fastidieux et difficile.

Nous nous attendons à ce que vous n'ayez pas besoin de nos définitions de logiciel, ordinateur et autres termes. Nous imaginons que vous avez vos propres ordinateurs, probablement beaucoup plus avancés que le nôtre, et peut-être d'une architecture fondamentalement différente. Une fois que vous aurez compris l'aperçu et le guide ci-dessous, vous pourrez facilement accéder à toutes les données.

Cependant, il est possible que vous ayez des ordinateurs inférieurs aux nôtres, voire aucun ordinateur. Dans le cas de cette éventualité, nous avons préparé une bobine de données non compressée, non codée et lisible par l'homme que nous appelons l'arbre technologique. L'arbre technologique contient des informations sur nos technologies fondamentales, nos ordinateurs et nos logiciels, dans l'espoir qu'au fil du temps, vous pourrez utiliser ces connaissances pour recréer des ordinateurs qui peuvent utiliser les logiciels open source de ces archives.

## Qu'est-ce qu'il y a à l'intérieur

L'archive est si grande - environ 24 billions d'octets (expliqués ci-dessous) - car elle est extrêmement inclusive et démocratique. Des millions de personnes mettent le logiciel qu'elles écrivent à la disposition de tous. Cette archive comprend un instantané - c'est-à-dire une seule copie, à un seul instant - de tous les logiciels publics que les utilisateurs de GitHub développent activement. Cela signifie qu'il comprend des dizaines de millions de référentiels séparés. Nous espérons que cette approche large et démocratique intéressera les historiens de l'avenir.

Les référentiels inclus dans cette archive ont été déterminés uniquement par leur dernière heure de validation, c'est-à-dire la dernière fois qu'ils ont été mis à jour, et leur nombre d'étoiles. (Les utilisateurs de GitHub peuvent tous «mettre en vedette» les référentiels publics, pour indiquer qu'ils présentent un intérêt ou une signification pour eux.) L'instantané a été lancé le 02/02/2020, c'est-à-dire le deuxième jour du mois de février, en l'année 2020 du calendrier grégorien, comme on compte le temps. Les référentiels qui y sont inclus sont: tous les référentiels avec des validations au cours des 80 jours précédents; tous les référentiels avec au moins une étoile avec des validations au cours des 365 jours précédents; et tous les référentiels avec au moins 250 étoiles, quelle que soit la date de leur dernière mise à jour.

Bien sûr, tous ces référentiels ne sont pas tout aussi importants en termes d'influence et de dépendances. L'arbre technologique comprend un index et une brève description des référentiels les plus importants de l'archive, et des listes sur lesquelles chacun peut être trouvé, de sorte qu'ils puissent être consultés sans avoir à parcourir tous ces millions de référentiels pour déterminer lesquels sont les plus pratiques. utile.


## Un aperçu des archives

L'archive se compose de 201 bobines de film: une "bobine guide" d'informations et de conseils lisibles par l'homme, et 200 bobines de logiciels archivés. Chaque bobine comprend 65 000 cadres individuels. Les cadres au début de chaque bobine et les cadres de la bobine de guidage comprennent du texte et des images lisibles par l'homme. Toutes les autres images de film sont constituées de données numériques stockées sous une forme visuelle connue sous le nom de codes QR.

Les données numériques signifient des données finalement stockées au format binaire, c'est-à-dire sous forme de 0 et de 1, car les ordinateurs eux-mêmes sont binaires - contrôlés par des signaux électriques qui sont soit "allumés" soit "éteints", correspondant à 1 ou 0 - et donc les données binaires sont les ordinateurs sont beaucoup plus faciles à comprendre que les autres.

Les métadonnées lisibles par l'homme stockées au début de chaque bobine incluent des informations sur le film lui-même, un guide pour l'encodage QR utilisé, un logiciel pour le décoder et un index. L'index répertorie le titre, le numéro de trame de début et la somme de contrôle pour chaque fichier stocké sur cette bobine.

Un fichier est une seule entité de données cohérente. Une somme de contrôle est une valeur unique d'un calcul, appelée fonction de hachage, exécutée sur tout le contenu d'un fichier, pour garantir que son contenu n'a pas été endommagé ou corrompu; la fonction de hachage utilisée dans l'archive est connue sous le nom de SHA-1.


Chaque code QR se compose d'un champ de minuscules carrés blancs ou noirs qui occupent presque toute l'image du film. Nous utilisons des codes QR car ils sont beaucoup plus compacts et robustes que le texte lisible par l'homme. Un code QR se décode en données binaires, c'est-à-dire une série de uns et de zéros.

Ce décodage n'est que la première étape pour transformer ces données binaires en informations significatives. Ce sont des données compressées, ce qui signifie qu'elles ont été compactées pour économiser de l'espace, de la même manière que l'on pourrait écrire "128xA" plutôt que d'écrire la lettre A 128 fois. Après avoir été décodé, il doit être décompressé.

Le résultat après décompression est connu sous le nom de fichier archive: un fichier unique contenant tout le contenu du référentiel d'un seul projet logiciel. La plupart des référentiels contiennent de nombreux fichiers, donc ce fichier d'archive est comme un livre contenant de nombreux chapitres séparés, ou une boîte contenant de nombreuses autres boîtes. Il est généralement avantageux, mais pas absolument nécessaire, de décompresser le fichier archive dans ses fichiers composants avant d'y accéder.

Enfin, chaque fichier composant est son propre ensemble de données binaires, c'est-à-dire des uns et des zéros. On peut donner un sens aux données si vous connaissez leur format. Par exemple, dans le format connu sous le nom «UTF-8», le format le plus courant dans l'archive, les uns et les zéros sont divisés en groupes de huit, appelés octets, l'octet 01000001 représente la lettre A; les trois octets 01101001 01101110 01110100 représentent le mot int; et les deux octets 11000011 10000011 représentent la lettre Ã (A avec un accent tilde en haut.)

Ce processus d'archivage de données, des fichiers binaires emballés dans des fichiers d'archive qui ont d'abord été compressés puis encodés en QR, est évidemment complexe par rapport à la simple écriture d'un texte lisible par l'homme. Le processus de désarchivage que vous devrez suivre - QR en binaire compressé; compressé à non compressé; archiver le fichier dans plusieurs fichiers; fichiers texte en texte lisible par l'homme - est tout aussi complexe. C'est parce que cette complexité nous permet de stocker beaucoup plus de données que ce qui serait autrement possible, d'une manière relativement facilement lisible par ordinateur.

Si cette complexité est difficile et coûteuse pour vous, nous nous en excusons, mais nous nous attendons à ce que, si tel est le cas, ce guide et l'arbre technologique lisible par l'homme atténueront cette complexité et pourraient peut-être vous être plus utiles que le le contenu de l'archive, au moins jusqu'à ce que vos ordinateurs soient suffisamment avancés pour que la complexité des données de l'archive soit facile à gérer.

## Fichiers, répertoires, référentiels et formats de données

Il peut être instructif de discuter de la manière dont l'archive est logiquement divisée. En particulier, une discussion sur les fichiers, les répertoires et les formats de données sera probablement utile.

Un fichier est une collection de données regroupées en une entité cohérente avec un seul nom: considérez les données comme du sable, et un fichier comme une sorte de sac qui peut contenir du sable, et seulement du sable. Un répertoire est une collection de fichiers: considérez-le comme une sorte de sac qui ne peut contenir que d'autres sacs. Suite à cette métaphore, chaque référentiel se compose d'un répertoire externe, appelé répertoire racine, qui contient un certain nombre de fichiers et / ou un certain nombre de répertoires. Chaque répertoire peut, à son tour, contenir à la fois des fichiers et des répertoires.

Cette structure est préférable car les fichiers organisés en groupes sont beaucoup plus faciles à utiliser qu'une seule collection de fichiers. L'identifiant d'un fichier particulier dans le répertoire externe se compose des noms de tous ses répertoires englobants, en commençant par la racine, suivi de son propre nom individuel, avec un caractère / entre chaque nom. Par exemple, un fichier nommé README.md dans le répertoire racine serait identifié comme /README.md et un fichier identifié comme /public/www/index.html serait le fichier index.html dans le répertoire 'www' à l'intérieur du ' public 'dans le répertoire racine.

Chaque référentiel a à son tour deux noms, séparés par un séparateur, qui dans l'archive est un caractère _ ou un trait de soulignement. (Historiquement, il s'agit d'une barre oblique /, mais qui est également utilisée pour indiquer un répertoire, nous utilisons donc _ pour plus de clarté.) Le premier nom est le compte GitHub qui possède ce référentiel; le second est le nom du référentiel individuel. La combinaison d'identifiants de référentiel et de fichier peut être utilisée pour identifier de manière unique un fichier individuel dans l'archive. Par exemple, le fichier 'package.json' dans le répertoire 'web' dans le référentiel 'ykarma' dans le compte GitHub 'rezendi' pourrait être identifié de manière unique comme /web/package.json dans rezendi_ykarma dans l'archive.


Différents types de fichiers ont des objectifs différents. L'archive GitHub se compose en grande partie de fichiers texte, c'est-à-dire de fichiers dont les données sont censées représenter le langage écrit. La plupart des logiciels sont écrits dans des fichiers texte contenant du texte hautement structuré appelé code source. Un programme spécial appelé compilateur convertit ce code source lisible par l'homme en instructions lisibles par ordinateur appelées code compilé ou code machine.

Les fichiers qui ne sont pas des fichiers texte, tels que les fichiers qui représentent des images visuelles ou contiennent du code compilé, sont souvent appelés fichiers binaires. C'est malheureusement un terme trompeur, car les fichiers texte sont également des 1 et des 0. Nous ferons référence aux fichiers qui ne sont pas des fichiers texte comme des fichiers non texte.

Il existe de nombreuses façons de représenter le langage humain écrit à l'aide de 1 et de 0. Pour des raisons historiques, la plupart du code source a été écrit à l'origine dans ce que l'on appelle l'écriture latine. L'écriture latine a 26 caractères de base qui sont utilisés pour représenter des mots parlables, chacun ayant deux formes, en majuscules et en minuscules. Il a également 10 chiffres pour représenter les nombres. L'écriture latine, ainsi que divers autres symboles associés utilisés pour indiquer la structure et d'autres concepts, est codée en 1 et en 0 dans un format appelé `` ASCII '', qui peut représenter 128 caractères différents et, pour des raisons historiques, a dominé la plupart des logiciels pendant de nombreuses années .

Cependant, l'écriture latine n'est qu'un petit sous-ensemble des nombreuses façons dont les humains s'expriment dans la langue écrite. Pour prendre en charge d'autres scripts, tout en permettant à tous les logiciels qui avaient été écrits pour utiliser ASCII de continuer à fonctionner sans changement (un concept connu sous le nom de compatibilité descendante), un autre format de données appelé «UTF-8» a été introduit.

ASCII reste le format de code source le plus courant. Chaque bobine de cette archive comprend un guide des caractères ASCII. ASCII est un sous-ensemble de UTF-8, c'est-à-dire que tous les encodages ASCII sont également des encodages UTF-8. La bobine de guidage contient en outre une spécification de tous les caractères UTF-8. Presque tous les fichiers texte de cette archive doivent être encodés en UTF-8.

Les fichiers non textuels incluent des fichiers destinés à représenter des images et des documents formatés. Une convention largement utilisée est que les noms de fichiers se terminent par un '.' caractère suivi d'un suffixe indiquant le type de fichier. Par exemple, un nom de fichier qui se termine par .jpg est probablement un fichier image JPEG; celui qui se termine par .PNG est probablement un fichier d'image graphique de réseau portable; et un qui se termine par .pdf un fichier au format de document portable.

Il n'y a pas de suffixe unique qui indique les fichiers texte. Au contraire, pour le code source, le suffixe est plus susceptible d'indiquer dans quel langage de programmation ou de balisage le code est écrit. Les langages de programmation et de balisage seront décrits plus en détail ci-dessous.

## Comment extraire le contenu de l'archive

1.  Ici, nous allons fournir un aperçu de la façon de décompresser un référentiel archivé particulier dans ses différents fichiers constitutifs. Encore une fois, ce processus consiste en:

2.  Identifier la bobine et les images spécifiques sur lesquelles les données du référentiel sont archivées.

3.  Décodage à partir des codes QR, des champs de pixels noirs, blancs et gris sur ces images, dans un fichier binaire, une séquence de (au moins des milliers et souvent des millions de) 1 et 0.

4.  Décompression du fichier binaire dans un fichier d'archive plus long et non compressé.

5.  Décompression du fichier d'archive dans les sous-fichiers séparés qu'il contient. Notez cependant que les données d'archive sont généralement compréhensibles, bien que désordonnées, même si cette étape est omise.

Enfin, la conversion de chacun de ces sous-fichiers - eux-mêmes des séquences de 1 et de 0 pouvant aller de très court à très long - en caractères écrits, s'il s'agit de fichiers texte.

Identifier la bobine et les cadres spécifiques sur lesquels les données du référentiel sont archivées
Chaque bobine de film commence par un leader de film vide, puis le cadre de référence zéro, qui consiste en un rectangle noir uni dans un coin d'une image autrement vide. Le prochain cadre lisible par l'homme est le cadre de contrôle, avec des informations sur la bobine. Vous trouverez ci-après la table des matières, qui comprend à son tour une liste de fichiers de données utilisateur.

Chaque référentiel sur cette bobine est l'un de ces fichiers de données utilisateur. La liste comprend un ID unique, un ID de fichier et un nom pour chacun de ces fichiers. Par exemple, le référentiel CPython du compte Python peut avoir l'ID de fichier répertorié comme 12345 et le nom répertorié comme python_cpython.tar.

Après la liste des fichiers de données utilisateur se trouve une liste des emplacements de données numériques. Cette liste comprend l'ID de fichier, une image de début, un octet de début, une image de fin et un octet de fin. Ainsi, en utilisant l'exemple hypothétique de CPython, l'élément de cette liste avec l'ID 12345 peut avoir une image de début de 054321, un octet de début de 03210321, une image de fin de 054545 et un octet de fin de 12321232.

Cela signifie, pour obtenir les données CPython: Allez à l'image 54321 de cette bobine de film. Décodez toutes les trames de la trame de début, 54321, à la trame de fin, 54545, en valeurs binaires, par les moyens décrits ci-dessous. Cela vous donnera 225 pièces de données numérotées de 54321 à 54545, qui commenceront par un ensemble de pièces vierges sans données. Jetez les 3210320 premiers octets dans la première donnée non vierge. Ajoutez toutes les données «intermédiaires», dans l'ordre. Enfin, ajoutez les 12321232 premiers octets du dernier élément de données, 54545. Vous avez maintenant assemblé le référentiel CPython complet, en un seul fichier d'archive compressé.

## Décodage des codes QR dans un fichier binaire

Les détails sur la façon de décoder les images du film en données binaires se trouvent dans les informations de représentation lisibles par l'homme qui se trouvent à la suite de la table des matières au début de chaque bobine de film dans les archives. Ces informations se trouvent sur chaque bobine de sorte que, même si une bobine individuelle est séparée de l'archive, il sera toujours possible de déchiffrer son contenu. Ces informations de représentation comprennent, dans l'ordre:

1.Un guide du programme d'archivage GitHub (ce document)

2.Index descriptif GitHub, une liste et une brève description de tous les dépôts sur cette bobine

3.Description des informations de représentation

4.Conservation numérique et comment récupérer des données, un aperçu des détails de la récupération des données

5.Description du support de stockage

6.Technologie de récupération de données

7.Structure générique de bobine de conservation (format de bobine)

8.Description générique du format de trame 4K

9.Description de la bibliothèque de déballage (pour les codes QR)

10.Débloquer le code source de la bibliothèque

11.Spécification du format de données ASCII

12.Spécification du langage de programmation C

13.Code source du fichier d'archive TAR

14.Code source PDF

15.Spécification du format de fichier XZ (pour la compression / décompression, décrite ci-dessous)

Le sixième de ces éléments, le document sur la technologie de récupération des données, décrit les exigences et les processus pour utiliser un scanner pour capturer les données sur une seule image de film codée numériquement et les transformer en une forme pouvant être analysée par ordinateur. Le huitième d'entre eux, la description du format Generic 4K Frame, fournit les informations techniques, y compris le code source, nécessaires pour qu'un ordinateur prenne une telle image numérisée et la convertisse en données binaires.

Il est théoriquement possible, en principe, de convertir un référentiel de données encodées en QR en données binaires sans utiliser d'ordinateur. Cependant, ce serait extrêmement difficile et exigerait probablement un effort considérable de la part d'une communauté bien organisée pendant plusieurs semaines, voire des mois ou des années. Étant donné que le contenu des référentiels est un logiciel destiné à fonctionner sur un ordinateur, leur utilisation en l'absence d'un ordinateur serait au mieux minimale.

Dans le cas où les héritiers de cette archive n'ont pas d'ordinateurs, ils doivent conserver l'archive entière et en sécurité jusqu'à ce qu'ils le fassent. L'un des objectifs de l'arbre technologique lisible par l'homme est d'aider à accélérer le développement des technologies et des ordinateurs en cas de cette éventualité. (Son autre objectif est de codifier notre technologie et son développement pour les futurs historiens.)


